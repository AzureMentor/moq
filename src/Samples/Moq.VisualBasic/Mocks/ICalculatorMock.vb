'------------------------------------------------------------------------------
' <auto-generated>
'     This code was generated by a tool.
'
'     Changes to this file may cause incorrect behavior and will be lost if
'     the code is regenerated.
' </auto-generated>
'------------------------------------------------------------------------------

Option Strict On
Imports Sample
Imports System.Threading
Imports Moq.Sdk
Imports System
Imports System.Collections.ObjectModel
Imports System.Reflection
Imports Stunts
Imports System.Runtime.CompilerServices

Namespace Global.Mocks
Public Partial Class ICalculatorMock
        Implements ICalculator, IStunt, IMocked

        ReadOnly pipeline As BehaviorPipeline = New BehaviorPipeline()
        Dim _mock As IMock

        <CompilerGenerated>
        ReadOnly Property Behaviors As ObservableCollection(Of IStuntBehavior) Implements IStunt.Behaviors
            Get
                Return pipeline.Behaviors
            End Get
        End Property

        ReadOnly Property Mock As IMock Implements IMocked.Mock
            Get
                Return LazyInitializer.EnsureInitialized(_mock, (Function() New DefaultMock(Me)))
            End Get
        End Property

        <CompilerGenerated>
        Public ReadOnly Property IsOn As Boolean Implements ICalculator.IsOn
            Get
                Return pipeline.Execute(Of Boolean)(New MethodInvocation(Me, MethodBase.GetCurrentMethod()))
            End Get
        End Property

        <CompilerGenerated>
        Public Property Mode As CalculatorMode Implements ICalculator.Mode
            Get
                Return pipeline.Execute(Of CalculatorMode)(New MethodInvocation(Me, MethodBase.GetCurrentMethod()))
            End Get
            Set(value As CalculatorMode)
                pipeline.Execute(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), value))
            End Set
        End Property

        <CompilerGenerated>
        Default Public Property Item(name As String) As Integer? Implements ICalculator.Item
            Get
                Return pipeline.Execute(Of Integer?)(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), name))
            End Get
            Set(value As Integer?)
                pipeline.Execute(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), name, value))
            End Set
        End Property

        <CompilerGenerated>
        Public ReadOnly Property Memory As ICalculatorMemory Implements ICalculator.Memory
            Get
                Return pipeline.Execute(Of ICalculatorMemory)(New MethodInvocation(Me, MethodBase.GetCurrentMethod()))
            End Get
        End Property

        <CompilerGenerated>
        Public Sub TurnOn() Implements ICalculator.TurnOn
            pipeline.Execute(New MethodInvocation(Me, MethodBase.GetCurrentMethod()))
        End Sub

        <CompilerGenerated>
        Public Sub Store(name As String, value As Integer) Implements ICalculator.Store
            pipeline.Execute(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), name, value))
        End Sub

        <CompilerGenerated>
        Public Sub Clear(name As String) Implements ICalculator.Clear
            pipeline.Execute(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), name))
        End Sub

        <CompilerGenerated>
        Public Function Add(x As Integer, y As Integer) As Integer Implements ICalculator.Add
            Return pipeline.Execute(Of Integer)(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), x, y))
        End Function

        <CompilerGenerated>
        Public Function Add(x As Integer, y As Integer, z As Integer) As Integer Implements ICalculator.Add
            Return pipeline.Execute(Of Integer)(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), x, y, z))
        End Function

        <CompilerGenerated>
        Public Function TryAdd(ByRef x As Integer, ByRef y As Integer, ByRef z As Integer) As Boolean Implements ICalculator.TryAdd
            Dim returns As IMethodReturn = pipeline.Execute(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), x, y, z))
            x = DirectCast(returns.Outputs("x"), Integer)
            y = DirectCast(returns.Outputs("y"), Integer)
            z = DirectCast(returns.Outputs("z"), Integer)
            Return DirectCast(returns.ReturnValue, Boolean)
        End Function

        <CompilerGenerated>
        Public Function Recall(name As String) As Integer? Implements ICalculator.Recall
            Return pipeline.Execute(Of Integer?)(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), name))
        End Function

        <CompilerGenerated>
        Public Overrides Function ToString() As String
            Return pipeline.Execute(Of String
            )(New MethodInvocation(Me, MethodBase.GetCurrentMethod()))
        End Function

        <CompilerGenerated>
        Public Overrides Function Equals(obj As Object) As Boolean
            Return pipeline.Execute(Of Boolean
            )(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), obj))
        End Function

        <CompilerGenerated>
        Public Overrides Function GetHashCode() As Integer
            Return pipeline.Execute(Of Integer
            )(New MethodInvocation(Me, MethodBase.GetCurrentMethod()))
        End Function

        <CompilerGenerated>
        Public Custom Event TurnedOn As EventHandler Implements ICalculator.TurnedOn
            AddHandler(value As EventHandler)
                pipeline.Execute(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), value))
            End AddHandler
            RemoveHandler(value As EventHandler)
                pipeline.Execute(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), value))
            End RemoveHandler
            RaiseEvent(sender As Object, args As EventArgs)
            End RaiseEvent
        End Event
    End Class
End Namespace
